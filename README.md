# Impulse-JIT

Impulse — учебно-практический язык и рантайм с амбициями C++ по возможностям и простотой Go/Kotlin. Проект развиваем как полнофункциональный тулчейн с JIT, GC и своей VM без зависимости от LLVM.

## Видение и ценности

- **Статическая типизация без боли**: базовые примитивы, простые структуры, интерфейсы и generics уровня "достаточно", без тяжёлого ООП.
- **Безопасная память out-of-the-box**: дефолтный GC, отсутствие сырых указателей, ошибки по памяти ловим ранее.
- **Продуктивность разработчика**: модульная система, внятная диагностика, CLI-first workflow под Linux.
- **Контроль над исполнением**: собственный SSA IR, оптимизирующий JIT, возможность довести производительность до "пятёрочного" уровня (factorial/sort/primes).

## Структура тулчейна

| Слой | Роль | Технологии-кандидаты | Артефакт |
| --- | --- | --- | --- |
| Frontend | лексер, парсер, проверки типов, lowering | **C++ по умолчанию** (PEGTL/ANTLR); Go для быстрых прототипов | AST, типизированные узлы |
| IR Builder | SSA-конвертация, CFG, φ-инструкции | C++ (собственный SSA), допускается Go IR-пайплайн на ранних этапах | `ModuleIR` |
| Optimizer | DCE, const-prop, loop-simplify | C++ passes, небольшой Go-driver для тестов | оптимизированный IR |
| Bytecode & VM | сериализация, интерпретатор | Bootstrap на Go → основная VM на чистом C++ | `ImpulseBC`, runtime hooks |
| GC | mark & sweep (позже поколенческий) | C++ ядро (без внешних зависимостей) с Go-песочницей для экспериментов | heap manager |
| JIT | baseline → optimizing, trampolines | asmjit/DynASM/собственный эмиттер, пишем на C++ | нативные entrypoints |
| Tooling | CLI, тесты, sandbox | Go/Python (скрипты), C++ утилиты где проще | `impulsec`, bmark runner |

Полные спецификации разбиваем по отдельным документам (см. ниже), этот README — стартовая точка.

## Документация

| Файл | Содержимое |
| --- | --- |
| `docs/spec/grammar.md` | Грамматика, синтаксис, примеры кода |
| `docs/spec/types.md` | Типы, generics, Option/Result, контракты интерфейсов |
| `docs/spec/ir.md` | SSA-формат, байткод, описание инструкций |
| `docs/spec/runtime.md` | VM, GC, модель модулей, ошибки |
| `docs/spec/toolchain.md` | Технологический стек, схемы сборки, правила CI |

## Структура репозитория

```
Impulse-JIT/
	frontend/     # C++ lexer/parser/typechecker
	ir/           # SSA builder и оптимизации
	runtime/      # VM, GC, JIT
	cli/          # Go CLI obёртка (impulsec)
	tools/        # tooling, генераторы тестов
	tests/        # e2e и golden тесты
	benchmarks/   # factorial/sort/primes и др.
	docs/spec/    # спецификации
```

Workflow и CI описаны в `docs/spec/toolchain.md`.

## Сборка фронтенда и CLI

Чтобы `impulsec` мог вызвать C++ парсер, сначала собираем статическую библиотеку фронтенда (она появится в `build/frontend/libimpulse-frontend.a`), а затем запускаем Go-сборку CLI:

```bash
cmake -S . -B build
cmake --build build --target impulse-frontend
cd cli && go build ./...
```

После этого бинарь можно запускать напрямую:

```bash
./cli/impulsec --file path/to/module.imp
```

## Снимок языка

Every file is a module: первая строка `module ...;`, далее импорты и объявления. Ниже минимальный пример, отражающий текущую спецификацию (см. `docs/spec/grammar.md`):

```impulse
module demo::app;

import std::io;

interface Display {
	func toString(self) -> string;
}

struct Vec2 {
	x: float;
	y: float;
}

func magnitude(v: Vec2) -> float {
	return sqrt(v.x * v.x + v.y * v.y);
}

func main() -> int {
	let p: Vec2 = Vec2 { x: 3, y: 4 };
	print(magnitude(p));
	return 0;
}
```

Ключевые черты:
- строгая модульная система (`module`, `import`, в будущем `export`);
- обязательные явные типы в сигнатурах, локальный вывод (`let x = 5` → `int`);
- интерфейсы и generics в стиле Go, но с жёсткими constraint'ами;
- `Result` и `Option` как основной способ работы с ошибками (без нативных исключений);
- pattern matching и `match` для enum'ов и опциональных значений.

## Технологический стек и фичи

- **C++ first**: если можно обойтись без тяжёлых внешних библиотек, компонент пишем на modern C++ (17+) для контроля и производительности.
- **Go для скорости**: прототипы, CLI, генераторы тестов и песочницы пишем на Go, чтобы быстро проверять идеи.
- **Свои фичи, не "ещё один Go"**: обязательный `Result`-поток ошибок, интерфейсы по композиции, модульная система без `#include`, собственный IR/JIT.
- **Минимум магии**: никакого скрытого `unsafe`, строгие спецификации в `docs/spec/*`.

## Бенчмарки и критерии курса

Проект должен демонстрировать корректность и производительность на трёх программах:

- factorial(20) — рекурсия, стек, большие числа;
- сортировка массива 10 000 элементов — loops, сравнения, память;
- простые числа ≤ 100 000 — массивы, арифметика, плотные циклы.

Сценарий оценки: показываем прогон этих программ, для оценки "5" — вручную реализуем и запускаем дополнительный бенчмарк за 2 часа.

## Дорожная карта

1. **Specification Sprint** — фиксируем грамматику, систему типов, bytecode/IR форматы (см. `docs/spec`).
2. **Frontend MVP** — lexer+parser+typechecker на Go, CLI `impulsec` с режимом `--emit-ir`.
3. **VM Bootstrap** — интерпретатор bytecode, базовый GC stub, исполнение бенчмарков без JIT.
4. **GC & Runtime** — mark-and-sweep, мини-stdlib (строки, массивы, print, timers).
5. **Baseline JIT** — эмиссия машинного кода, trampolines, профилировка "горячих" участков.
6. **Optimizing Passes** — константная свёртка, упрощение CFG, подготовка к showcase.

## Команда и процессы

- 3–4 человека: frontend/AST, IR/оптимизации, VM/GC, JIT/инструменты.
- Кодстайл: Google C++ Style / `gofmt` (в зависимости от компонента), проверки в CI.
- Документацию ведём в `docs/spec`, каждое изменение языка сопровождаем обновлением соответствующего файла.

---

Дальше заполняем спецификации: начнём с оглавлений и базовых договорённостей, затем будем детализировать каждый слой.
