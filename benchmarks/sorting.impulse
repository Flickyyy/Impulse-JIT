module benchmark::sorting;

// Benchmark: Sort array of 1000 elements
// Algorithm: Iterative Quicksort (using explicit stack to avoid deep recursion)
// Demonstrates: array handling, loops, stack-based iteration, element comparison
// Expected result: 1 (array is correctly sorted)

func swap(arr: array, i: int, j: int) -> int {
    let temp: int = array_get(arr, i);
    array_set(arr, i, array_get(arr, j));
    array_set(arr, j, temp);
    return 0;
}

func partition(arr: array, low: int, high: int) -> int {
    let pivot: int = array_get(arr, high);
    let i: int = low - 1;
    let j: int = low;
    
    while j < high {
        if array_get(arr, j) <= pivot {
            i = i + 1;
            swap(arr, i, j);
        }
        j = j + 1;
    }
    
    i = i + 1;
    swap(arr, i, high);
    return i;
}

func quicksort(arr: array, low: int, high: int) -> int {
    // Use an array as a stack to store (low, high) pairs
    // Push low first, then high, so we pop high then low
    let stack: array = array(0);
    array_push(stack, low);
    array_push(stack, high);
    
    while array_length(stack) > 0 {
        // Pop high, then low (we need at least 2 elements)
        if array_length(stack) < 2 {
            break;
        }
        let h: int = array_pop(stack);
        let l: int = array_pop(stack);
        
        if l < h {
            let pi: int = partition(arr, l, h);
            
            // Only push valid (non-empty) partitions
            // Left partition: [l, pi-1] is valid if l < pi
            // Right partition: [pi+1, h] is valid if pi < h
            
            if pi < h {
                // Right partition is valid, push it
                array_push(stack, pi + 1);
                array_push(stack, h);
            }
            if l < pi {
                // Left partition is valid, push it
                array_push(stack, l);
                array_push(stack, pi - 1);
            }
        }
    }
    
    return 0;
}

func is_sorted(arr: array) -> int {
    let n: int = array_length(arr);
    let i: int = 0;
    while i < n - 1 {
        if array_get(arr, i) > array_get(arr, i + 1) {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}

func fill_descending(arr: array, n: int) -> int {
    let i: int = 0;
    while i < n {
        array_set(arr, i, n - i);
        i = i + 1;
    }
    return 0;
}

func main() -> int {
    let size: int = 1000;
    let arr: array = array(size);
    
    fill_descending(arr, size);
    quicksort(arr, 0, size - 1);
    
    return is_sorted(arr);
}
