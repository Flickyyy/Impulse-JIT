# Control Flow Graph (CFG)

## Overview

The CFG builder constructs a graph view of an `ir::Function`. Nodes correspond to
basic execution regions and edges represent possible control transfers.

This graph is used as the foundation for later optimisation passes (SSA
construction, data-flow analysis, etc.). The current implementation works with
our flattened stack-machine IR and automatically discovers block leaders from the
instruction stream.

## Role in the Pipeline

- **Consumes**: Flattened IR generated by the lowering phase. The instructions are still in evaluation order, but not organised into explicit basic blocks.
- **Produces**: `ControlFlowGraph` instances that record block boundaries, successor/predecessor edges, and a pointer back to every original instruction.
- **Feeds**: SSA construction, dominance computation, data-flow analyses (RPO traversals, liveness, etc.). SSA relies on these block boundaries to insert `phi` nodes, while future analyses (dead code elimination, loop optimisation, instruction scheduling) depend on the same topology to reason about execution order.

By materialising the CFG once, every subsequent pass can reuse the topology without recomputing branch structure. Reverse-postorder and DFS walks used in SSA and dominance analysis are derived directly from this graph.

## Block Formation

Blocks are created by scanning the flattened instruction list and marking
*leaders*:

- The first instruction of the function.
- Any `label` instruction (`InstructionKind::Label`).
- The instruction following a terminator (`branch`, `branch_if`, `return`).

Each block stores the half-open range `[start_index, end_index)` into the
flattened instruction vector. The first meaningful instruction (ignoring
comments) determines its behaviour.

Generated block names follow this order of preference:

1. A leading `label` instruction operand (`L0`, `L1`, ...).
2. The original `BasicBlock` label when the block starts at the first instruction
   of that basic block (e.g. `entry`).
3. An auto-generated identifier (`block#`).

The CFG keeps a `label_to_block` map for resolving branch targets to block
indices.

## Successors

Successor edges are computed from the block terminator (last non-label,
non-comment instruction):

- `branch`: single successor to the labelled target.
- `branch_if`: two successors — the labelled target and the fallthrough block.
- `return`: no successors.
- Other instructions: implicit fallthrough to the next block when one exists.

Predecessor lists are derived from successor edges after the initial pass.

## API

```
struct ControlFlowGraph::Block {
  std::string name;              // Human-friendly identifier
  std::size_t start_index;       // Index into flattened instruction vector
  std::size_t end_index;         // Exclusive end index
  std::vector<std::size_t> successors;
  std::vector<std::size_t> predecessors;
};

struct ControlFlowGraph {
  std::vector<Block> blocks;
  std::vector<const Instruction*> instructions;
  std::unordered_map<std::string, std::size_t> label_to_block;

  const Block* find_block(const std::string& label) const;
};

ControlFlowGraph build_control_flow_graph(const Function&);
```

### Example

For the following IR snippet:

```
literal cond
branch_if Lelse when 0
literal 1
return
label Lelse
literal 0
return
```

The CFG yields three blocks:

1. `entry` → successors `{Lelse, block1}`
2. `block1` → returns
3. `Lelse` → returns

## Extensibility Notes

- The current builder operates on the flattened instruction stream. Once the IR
  migrates to multi-block form, the leader detection still works without
  modification.
- Additional terminators (e.g. `throw`, `call_indirect`) must be added to
  `is_terminator` to keep the graph complete.
- The CFG is stored alongside the flattened instruction view, avoiding copies
  and enabling future passes (SSA, DFG) to reference original instructions.
