# Система типов Impulse

## 1. Базовые принципы
- Статическая проверка выполняется до генерации IR; фронтенд обязан выводить все типы выражений.
- Нуллабельность запрещена: вместо `null` используются `Option[T]`, `Result[T,E]`, либо явные sentinel-значения.
- Отсутствие неявных преобразований: каждая конверсия оформляется как функция/оператор.
- Generics — first-class, но без метапрограммирования/partial specialization.

## 2. Примитивы

| Тип | Описание |
| --- | --- |
| `int` | 64-битное знаковое целое |
| `uint` | 64-битное беззнаковое |
| `float` | 64-битный IEEE754 |
| `bool` | `true`/`false`, хранится как 1 байт |
| `string` | UTF-8, неизменяемая, хранит длину + указатель на байты |

План расширения: `i8/u8/i32/u32`, фиксированные массивы `[T; N]`, `decimal`.

## 3. Составные типы

### Структуры
```
struct Vec2 {
	x: float;
	y: float;
}
```
- Поля приватные по умолчанию; `pub` (в roadmap) делает их экспортируемыми.
- Конструктор — это просто функция `Vec2 { x: 0, y: 0 }`.

### Интерфейсы
- Модель Go: тип удовлетворяет интерфейсу, если реализует все методы.
- Нет явного `implements`; проверки происходят в момент использования (при присвоении в интерфейсную переменную или при подстановке в generic).

```
interface Display {
	func toString(self) -> string;
}

func printAll<T: Display>(items: [T]) { ... }
```

### Срезы и массивы
- Динамический массив: `[]T` (срез) хранит `ptr + len + cap`.
- Фиксированный массив `[T; N]` — значение (копируется). Срез можно получить `arr[..]`.

## 4. Обработка ошибок и контроль потоков
- `Result<T, E>`: enum вида `Result = Ok(T) | Err(E)`.
- `Option<T>`: `Some(T)` или `None`.
- Оператор `?` (позже) для короткого выхода из функции при `Err/None`.
- `panic(msg)` выбрасывает неперехватываемое событие, завершает поток выполнения до границы модуля/рантайма.

## 5. Generics
- Синтаксис: `func max<T: Comparable>(a: T, b: T) -> T` или `struct Box<T>`.
- Ограничения указываются через интерфейсы. Несколько ограничений записываются через `&` (`T: Readable & Writable`).
- Мономорфизация на этапе компиляции: для каждого набора типов генерируется версия функции/структуры.
- Вывод типов при вызове: если аргументы определяют `T`, то `<>` можно опустить.

## 6. Вывод типов
- Локальный вывод (let): `let x = 42;` → `x: int`.
- Для параметров функций требуется явное указание типов.
- Алгоритм HM-подобный, но без higher-kinded типов.

## 7. Ссылки и владение
- Значения по умолчанию копируются (semantics of value). Для больших структур можно объявить поле типа `ref T` — дескриптор на heap.
- `ref` гарантирует управление GC, нет ручного `free`.
- Мутирование осуществляется через `var` переменные либо методы со `mut self` (в roadmap).

## 8. Совместимость типов
- Неявных up/down-кастов нет.
- Интерфейсы: значение типа `T` можно присвоить переменной типа `I`, если `T` реализует `I`.
- `match` по enum'ам обязателен исчерпывающий.

## 9. Будущие расширения
- `enum` и algebraic data types.
- `const`-generic (размеры массивов).
- `opaque type` для модульных границ.
